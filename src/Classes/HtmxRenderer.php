<?php

namespace App\Classes;

use DOMDocument;
use DOMElement;
use DOMNode;
use DOMXPath;
use Psr\Http\Message\ResponseInterface;
use Slim\Views\PhpRenderer;

class HtmxRenderer extends PhpRenderer
{

   private bool $partialLoaded = false;

   public function render(ResponseInterface $response, string $template, array $data = []): ResponseInterface
   {
      $response = parent::render($response, $template, $data);
      if ($this->isHxRequest() && $this->partialLoaded != true) {
         $response = $response->withStatus(204);
      }
      return $response;
   }

   protected function protectedIncludeScope(string $template, array $data): void
   {
      extract($data);
      $markup = file_get_contents($template);
      $markup = $this->asPartial($markup);
      $markup = $this->stripHx($markup);
      $markup = $this->withCustomExpressions($markup);
      eval ("?>" . $markup);
   }

   public function withCustomExpressions(string $extendedHtml)
   {
      $pattern = '/{{\s?(\$\S*)\s?}}/';

      // Handle {{ $variable }} syntax. Support for filters
      $extendedHtml = preg_replace_callback($pattern, function ($matches) {
         $expression = $matches[1];
         return "<?= htmlspecialchars($expression, encoding: 'UTF-8') ?>";
      }, $extendedHtml);

      // Same as above but unescaped
      $pattern = '/{{!unescaped\s(\$\S*)\s?}}/';
      $extendedHtml = preg_replace_callback($pattern, function ($matches) {
         $expression = $matches[1];
         return "<?= $expression ?>";
      }, $extendedHtml);

      return $extendedHtml;
   }

   private function asPartial(string $inputHtml)
   {
      $dom = $this->makeDom($inputHtml);
      $elements = $dom->getElementsByTagName('hx-partial');
      $outputHtml = $inputHtml;
      
      foreach ($elements as $i => $hxElement) {
         if ($this->routeMatches($hxElement) && $this->methodMatches($hxElement)) {
            if ($this->isHxRequest()) {
               $this->partialLoaded = true;
               return $this->getHxPartialContent($i, $inputHtml);
            }
         } else {
            $subHtmx = $this->getHxPartialContent($i, $inputHtml, true);
            $outputHtml = str_replace($subHtmx, "", $outputHtml);
         }
      }

      return $outputHtml;
   }
   
   private static function getHxPartialContent(int $tagGroupIndex, string $extendedHtml, bool $withEnclosingTags = false){
      $matches = [];
      preg_match_all("/<hx-partial.*>/", $extendedHtml, $matches, PREG_OFFSET_CAPTURE);
      $matches = $matches[0];
      $startTag = $matches[$tagGroupIndex][0];
      $startTagOffset = $matches[$tagGroupIndex][1];
      preg_match_all("/<\/hx-partial.*>/", $extendedHtml, $matches, PREG_OFFSET_CAPTURE);
      $matches = $matches[0];
      $endTag = $matches[$tagGroupIndex][0];
      $endTagOffset = $matches[$tagGroupIndex][1];
      
      if(!$withEnclosingTags){
         $startTagOffset += strlen($startTag);
         $endTagOffset -= $startTagOffset;
      }
      else {
         $endTagOffset -= $startTagOffset;
         $endTagOffset += strlen($endTag);
      }
      return substr($extendedHtml, $startTagOffset, $endTagOffset);
   }
   
   function strpos_all(string $haystack, string $needle, int $target) {
      $positions = array();
      $offset = 0;
      
      while (($pos = strpos($haystack, $needle, $offset)) !== false) {
          $positions[] = $pos;
          $offset = $pos + strlen($needle);
      }
      
      return $positions[$target];
  }
         
   private function routeMatches(DOMElement $hxElement){
      $paths = explode('||', $hxElement->getAttribute('route'));      
      return in_array($this->requestUri(), $paths);
   }
   
   private function methodMatches(DOMElement $hxElement){
      return str_contains(strtoupper($hxElement->getAttribute('method')), $this->requestMethod());
   }
   
   private function innerHtml(DOMDocument $dom, DOMElement $element): string
   {
      $innerHtml = '';
      foreach ($element->childNodes as $childNode) {
         $innerHtml .= $dom->saveHTML($childNode);
      }
      return $innerHtml;
   }
   
   private function requestUri() {
      return $_SERVER['REQUEST_URI'];     
   }
   
   private function requestMethod() {
      return $_SERVER['REQUEST_METHOD'];
   }
   
   private function isHxRequest(){
      return isset($_SERVER['HTTP_HX_REQUEST']);
   }
   
   private function isHxBoosted(){
      return isset($_SERVER['HTTP_HX_BOOSTED']);
   }
   
   /**
    * Remove hx-tags from the output
    */
    private function stripHx(string $extendedHtml)
    {
  
       $hxTags = ['hx-partial'];
       foreach ($hxTags as $hxTag) {
         $pattern = "/<\/?$hxTag?.+\/?>/";
         $extendedHtml = preg_replace($pattern, "", $extendedHtml);
       }
        
       if ($this->partialLoaded) {
          // Remove body and html tags generated by DOMDocument
          $extendedHtml = str_replace(["<body>", "</body>", "<html>", "</html>"], "", $extendedHtml);
          // Remove !Doctype generated by DOMDocument
          $extendedHtml = preg_replace('/\<!DOCTYPE.+\s?\n/', "", $extendedHtml);
       }
       return $extendedHtml;
    }
    
    private function makeDom(string $extendedHtml){
      // Initialize DOMDocument
      $dom = new DOMDocument();
      // Suppress warnings due to malformed HTML
      libxml_use_internal_errors(true);
      // Load the HTML
      $dom->loadHTML($extendedHtml);
      // Clear errors
      libxml_clear_errors();
      // Get all elements by tag name
      
      return $dom;
   }
}